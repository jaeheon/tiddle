{-
Copyright (c) 2012, Caitlin Sadowski (University of California, Santa Cruz)
                    and Jaeheon Yi (University of California, Santa Cruz).
All Rights Reserved.
-}

module Main where
import Text.PrettyPrint.HughesPJ
import System.Environment
import Parser
import Lexer
import Syntax as S
import ToJavaBarriers
import JavaAST as J --hiding
import Data.List
import System.IO

{--------- Main function -----------}
main = do putStrLn "---------please enter classname:"
          cls <- getLine
          putStrLn "---------enter contents (followed by ctrl-d):"
          s <- getContents
          writeFile (cls ++ ".java") ((comments s) ++ (code cls s))
            where 
              code cls s = render $ pretty $ traceToJava "mypackage" cls (trace s)
              trace s     = parseTrace (alexScanTokens s)
              comments s = "//Generated by Tiddle, UC Santa Cruz\n/*\n" ++ s ++ "\n*/\n"

-- takes a packagename, classname and trace and creates a Java class for that trace
traceToJava :: String -> String -> Trace -> Class
traceToJava pack cls trace = let listVars  = nub $ [ x | Event t (Rd x v) <- trace] ++
                                          [ x | Event t (Wr x v) <- trace]  in
                    let listLocks = nub $ [ m | Event t (S.Lock m) <- trace] in
                    let listThreads = nub $ [ t | Event t _ <- trace] ++
                                            [ t | Event _ (S.Fork t) <- trace ] ++
                                            [ t | Event _ (S.Join t) <- trace ] in 
                    let initThreads = listThreads \\  
                             [ t | Event _ (S.Fork t) <- trace ] in
                    Class pack cls 
                           ([Decl TInt name 0 | name <- listVars] ++
                            [ObjDecl name | name <- listLocks])
                           initThreads
                           (threadBlocks trace listThreads)
                    where
                      threadBlocks trace threads = 
                      -- this is the important line:
                        [reverseStmts (foldl processOp (ThreadBlock t []) trace) 
                                                                    | t <- threads]
                      reverseStmts (ThreadBlock tid stmts) = ThreadBlock tid 
                                                                    (reverse stmts)
                        
                        
{---- Adds an operation or Nop to ThreadBlock for a thread ----}
processOp:: ThreadBlock -> Event -> ThreadBlock
processOp (ThreadBlock tid blk) (Event t (S.Fork tf))
  | t == tid  = ThreadBlock tid (addStmt blk (S.Fork tf) )
  | tid == tf = ThreadBlock tid []
  | otherwise = ThreadBlock tid (addNop blk)

processOp (ThreadBlock tid blk) (Event t op)
  | t == tid  = ThreadBlock tid (addStmt blk op)
  | otherwise = ThreadBlock tid (addNop blk)

{---------Correspondence between Op and Stmt datatypes--------}
opToStmt:: Op -> Stmt
opToStmt (Rd var val) = Read var val
opToStmt (Wr var val) = Write var val
opToStmt (S.Join tid) = J.Join tid 
opToStmt (S.Fork tid) = J.Fork tid
opToStmt (S.Lock obj) = J.Lock obj [] 
--opToStmt (Rel obj)    = Empty
opToStmt (Beg label)  = Trans label []
--opToStmt (End label)  = Empty

{---Translates an Op to a Stmt and adds it to a list of Stmts----}
addStmt:: [Stmt] -> Op -> [Stmt]
addStmt [] op                             = [opToStmt op]
--addStmt ((J.Lock obj (Empty:rest)):tl) op = (opToStmt op):(J.Lock obj (reverse rest)):tl  
addStmt ((J.Lock obj s):tl) (Rel o)     
                            | obj == o    = Empty:(J.Lock obj (reverse s)):tl
                            | otherwise   = (J.Lock obj (addStmt s (Rel o))):tl
addStmt ((J.Lock obj s):tl) op            = (J.Lock obj (addStmt s op)):tl 
addStmt ((Trans ll s):tl) (End l) 
                            | l == ll     = Empty:(Trans ll (reverse s)):tl 
                            | otherwise   = (Trans ll (addStmt s (End l))):tl
addStmt ((Trans l s):tl) op               = (Trans l (addStmt s op)):tl
addStmt (Empty:tl) op                     = (opToStmt op):tl 
addStmt stmts op                          = (opToStmt op):stmts

{--- Adds a Nop to a list of Stmts ------------}
addNop::[Stmt] -> [Stmt]
addNop []                             = [Nop]
--addNop ((J.Lock obj (Empty:rest)):tl) = Nop:(J.Lock obj (reverse rest)):tl  
addNop ((J.Lock obj stmts): tl)       = (J.Lock obj (addNop stmts)):tl 
addNop ((Trans ll s):tl)              = (Trans ll (addNop s)):tl
addNop (Empty:tl)                     = Nop:tl 
addNop  stmts                         = Nop:stmts



